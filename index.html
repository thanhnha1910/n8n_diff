<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DiffChecker - Advanced Document Comparison Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap");
      :root {
        --bg-color: #f8f9fa;
        --surface-color: #ffffff;
        --border-color: #e5e7eb;
        --text-primary: #1f2937;
        --text-secondary: #6b7280;
        --color-red: #fef2f2;
        --color-red-text: #991b1b;
        --color-green: #f0fdf4;
        --color-green-text: #166534;
        --color-blue: #667eea;
      }
      body {
        font-family: "Inter", sans-serif;
        background-color: var(--bg-color);
        margin: 0;
        padding: 40px;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        position: relative;
      }

      /* Ultra-Fast Reading Controls */
      .reading-progress-bar {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: rgba(0, 0, 0, 0.1);
        z-index: 1000;
        cursor: pointer;
        transition: height 0.2s ease;
      }

      .reading-progress-bar:hover {
        height: 8px;
      }

      .reading-progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea, #764ba2);
        width: 0%;
        transition: width 0.1s ease;
        position: relative;
      }

      .reading-progress-fill::after {
        content: attr(data-progress);
        position: absolute;
        right: 10px;
        top: -25px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        opacity: 0;
        transition: opacity 0.2s ease;
        pointer-events: none;
      }

      .reading-progress-bar:hover .reading-progress-fill::after {
        opacity: 1;
      }

      .main-container {
        width: 100%;
        max-width: 1200px;
        background: var(--surface-color);
        border-radius: 16px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.07);
        overflow: hidden;
        display: flex;
        flex-direction: column;
        height: 80vh;
        max-height: 800px;
      }
      .header {
        padding: 20px 30px;
        border-bottom: 1px solid var(--border-color);
      }
      .header-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 20px;
      }
      .header h1 {
        margin: 0;
        font-size: 1.5rem;
        color: var(--text-primary);
        flex: 1;
      }
      .btn-reset {
        background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.9rem;
        padding: 8px 16px;
        transition: all 0.2s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      }
      .btn-reset:hover {
        background: linear-gradient(135deg, #e5e7eb 0%, #d1d5db 100%);
        border-color: #9ca3af;
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }
      .btn-reset:active {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      }
      .btn-reset svg {
        transition: transform 0.2s ease;
      }
      .btn-reset:hover svg {
        transform: rotate(180deg);
      }
      .content-area {
        display: flex;
        flex: 1;
        overflow: hidden;
      }
      .diff-side {
        flex: 1;
        padding: 20px;
        border-right: 1px solid var(--border-color);
        position: relative;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      .diff-side:last-child {
        border-right: none;
      }
      .upload-zone {
        border: 2px dashed var(--border-color);
        border-radius: 12px;
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .upload-zone.drag-over {
        border-color: var(--color-blue);
        background-color: #f0f2ff;
      }
      .upload-zone p {
        color: var(--text-secondary);
      }
      .upload-zone strong {
        color: var(--color-blue);
      }
      .file-content-view {
        font-family: "Courier New", monospace;
        font-size: 14px;
        line-height: 1.6;
        white-space: pre-wrap;
        word-wrap: break-word;
        word-break: break-word;
        overflow-wrap: break-word;
        hyphens: auto;
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 15px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        background-color: #fafafa;
        max-height: 100%;
        scroll-behavior: auto;

        /* GPU Acceleration & Performance Optimizations */
        will-change: transform, scroll-position;
        transform: translateZ(0); /* Force GPU layer */
        contain: layout style paint; /* Isolate repaints */
        backface-visibility: hidden; /* Optimize 3D transforms */
        perspective: 1000px; /* Enable 3D context */

        /* Smooth scrolling performance */
        -webkit-overflow-scrolling: touch; /* iOS momentum scrolling */
        scroll-snap-type: y proximity; /* Snap to content */

        /* Optimize rendering */
        image-rendering: optimizeSpeed;
        text-rendering: optimizeSpeed;

        /* Reduce reflow/repaint */
        position: relative;
        z-index: 1;
      }
      .line-container {
        display: flex;
        align-items: flex-start;
        margin-bottom: 2px; /* Reduced spacing for better visual continuity */
        border-radius: 6px;
        transition: all 0.3s ease;
        position: relative;
        border: 2px solid transparent;
      }

      /* Enhanced line container highlighting for differences */
      .line-container.has-difference {
        border: 2px solid rgba(59, 130, 246, 0.3);
        background-color: rgba(59, 130, 246, 0.05);
        box-shadow: 0 2px 8px rgba(59, 130, 246, 0.1);
      }

      .line-container.has-addition {
        border: 2px solid rgba(34, 197, 94, 0.4);
        background-color: rgba(34, 197, 94, 0.08);
        box-shadow: 0 2px 8px rgba(34, 197, 94, 0.15);
      }

      .line-container.has-deletion {
        border: 2px solid rgba(239, 68, 68, 0.4);
        background-color: rgba(239, 68, 68, 0.08);
        box-shadow: 0 2px 8px rgba(239, 68, 68, 0.15);
      }

      .line-container.has-modification {
        border: 2px solid rgba(245, 158, 11, 0.4);
        background-color: rgba(245, 158, 11, 0.08);
        box-shadow: 0 2px 8px rgba(245, 158, 11, 0.15);
      }

      /* Line numbers with enhanced styling */
      .line-number {
        display: inline-block;
        width: 45px;
        padding: 4px 8px;
        background-color: #f8fafc;
        color: var(--text-secondary);
        font-size: 12px;
        text-align: right;
        border-right: 2px solid var(--border-color);
        margin-right: 10px;
        user-select: none;
        flex-shrink: 0;
        font-weight: 500;
        border-radius: 4px 0 0 4px;
      }

      /* Enhanced line number styling for different types */
      .line-container.has-addition .line-number {
        background-color: rgba(34, 197, 94, 0.1);
        border-right-color: rgba(34, 197, 94, 0.3);
        color: #059669;
        font-weight: 600;
      }

      .line-container.has-deletion .line-number {
        background-color: rgba(239, 68, 68, 0.1);
        border-right-color: rgba(239, 68, 68, 0.3);
        color: #dc2626;
        font-weight: 600;
      }

      .line-container.has-modification .line-number {
        background-color: rgba(245, 158, 11, 0.1);
        border-right-color: rgba(245, 158, 11, 0.3);
        color: #d97706;
        font-weight: 600;
      }

      .line {
        padding: 4px 12px;
        display: block;
        flex: 1;
        min-height: 24px;
        word-wrap: break-word;
        word-break: break-word;
        overflow-wrap: break-word;
        white-space: pre-wrap;
        max-width: 100%;
        box-sizing: border-box;
        border-radius: 0 4px 4px 0;
        position: relative;
      }

      /* Enhanced line styling with better visual indicators */
      .line.added {
        background: linear-gradient(
          90deg,
          rgba(34, 197, 94, 0.15) 0%,
          rgba(34, 197, 94, 0.08) 100%
        );
        border-left: 4px solid #22c55e;
        color: #065f46;
        font-weight: 500;
      }

      .line.deleted {
        background: linear-gradient(
          90deg,
          rgba(239, 68, 68, 0.15) 0%,
          rgba(239, 68, 68, 0.08) 100%
        );
        border-left: 4px solid #ef4444;
        color: #7f1d1d;
        font-weight: 500;
      }

      .line.modified-old {
        background: linear-gradient(
          90deg,
          rgba(239, 68, 68, 0.12) 0%,
          rgba(239, 68, 68, 0.06) 100%
        );
        border-left: 4px solid #f59e0b;
        color: #7c2d12;
        font-weight: 500;
      }

      .line.modified-new {
        background: linear-gradient(
          90deg,
          rgba(34, 197, 94, 0.12) 0%,
          rgba(34, 197, 94, 0.06) 100%
        );
        border-left: 4px solid #f59e0b;
        color: #064e3b;
        font-weight: 500;
      }

      .line.empty {
        background: linear-gradient(
          90deg,
          rgba(156, 163, 175, 0.1) 0%,
          rgba(156, 163, 175, 0.05) 100%
        );
        border-left: 4px solid #e5e7eb;
        min-height: 24px;
        position: relative;
      }

      /* Add visual indicator for empty lines */
      .line.empty::after {
        content: "∅";
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        color: #9ca3af;
        font-size: 14px;
        opacity: 0.6;
      }

      /* Enhanced inline diff highlighting */
      .inline-deleted {
        background-color: #f5c6cb;
        color: #721c24;
        border: 2px solid #dc3545;
        border-radius: 4px;
        padding: 2px 4px;
        margin: 0 1px;
        box-shadow: 0 2px 4px rgba(220, 53, 69, 0.2);
        transition: all 0.3s ease;
        font-weight: 600;
      }

      .inline-deleted:hover {
        background-color: #f1b0b7;
        box-shadow: 0 4px 8px rgba(220, 53, 69, 0.3);
        transform: translateY(-1px);
      }

      .inline-added {
        background-color: #c3e6cb;
        color: #155724;
        border: 2px solid #28a745;
        border-radius: 4px;
        padding: 2px 4px;
        margin: 0 1px;
        box-shadow: 0 2px 4px rgba(40, 167, 69, 0.2);
        transition: all 0.3s ease;
        font-weight: 600;
      }

      .inline-added:hover {
        background-color: #b8dabd;
        box-shadow: 0 4px 8px rgba(40, 167, 69, 0.3);
        transform: translateY(-1px);
      }

      /* Enhanced container classes for synchronized highlighting */
      .line-container.has-deletion {
        border-left: 4px solid #dc3545;
        background: linear-gradient(
          90deg,
          rgba(220, 53, 69, 0.05) 0%,
          transparent 100%
        );
      }

      .line-container.has-addition {
        border-left: 4px solid #28a745;
        background: linear-gradient(
          90deg,
          rgba(40, 167, 69, 0.05) 0%,
          transparent 100%
        );
      }

      .line-container.has-modification {
        border-left: 4px solid #ffc107;
        background: linear-gradient(
          90deg,
          rgba(255, 193, 7, 0.05) 0%,
          transparent 100%
        );
      }

      /* Synchronized hover effects */
      .line-container[data-line-pair]:hover {
        background: linear-gradient(
          90deg,
          rgba(59, 130, 246, 0.08) 0%,
          rgba(59, 130, 246, 0.02) 100%
        ) !important;
        border-left-color: #3b82f6 !important;
        transition: all 0.2s ease;
        transform: scale(1.01);
        z-index: 5;
      }

      /* Enhanced visual indicators for line pairs */
      .line-container[data-line-pair]::after {
        content: "";
        position: absolute;
        right: 0;
        top: 0;
        bottom: 0;
        width: 2px;
        background: transparent;
        transition: all 0.2s ease;
      }

      .line-container[data-line-pair]:hover::after {
        background: linear-gradient(
          to bottom,
          #3b82f6,
          rgba(59, 130, 246, 0.3)
        );
        box-shadow: 0 0 8px rgba(59, 130, 246, 0.4);
      }

      /* Fast scroll synchronization indicator */
      .file-content-view {
        scroll-behavior: auto;
      }

      /* Enhanced line number styling for synchronized lines */
      .line-container[data-line-pair] .line-number {
        position: relative;
      }

      .line-container[data-line-pair] .line-number::before {
        content: "";
        position: absolute;
        left: -2px;
        top: 50%;
        transform: translateY(-50%);
        width: 4px;
        height: 4px;
        border-radius: 50%;
        background: #6c757d;
        opacity: 0.3;
        transition: all 0.2s ease;
      }

      .line-container[data-line-pair]:hover .line-number::before {
        background: #3b82f6;
        opacity: 1;
        transform: translateY(-50%) scale(1.5);
      }

      .inline-modified {
        background-color: #ffeaa7;
        color: #856404;
        border: 2px solid #ffc107;
        border-radius: 4px;
        padding: 2px 4px;
        margin: 0 1px;
        box-shadow: 0 2px 4px rgba(255, 193, 7, 0.2);
      }

      /* Advanced Line Matching Styles */
      .correspondence-indicator {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: linear-gradient(45deg, #3b82f6, #1d4ed8);
        margin-right: 6px;
        position: relative;
        animation: pulse 2s infinite;
        box-shadow: 0 0 6px rgba(59, 130, 246, 0.4);
      }

      .correspondence-indicator::after {
        content: "";
        position: absolute;
        top: -2px;
        left: -2px;
        right: -2px;
        bottom: -2px;
        border: 1px solid rgba(59, 130, 246, 0.3);
        border-radius: 50%;
        animation: ripple 2s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }

      @keyframes ripple {
        0% {
          transform: scale(1);
          opacity: 1;
        }
        100% {
          transform: scale(1.5);
          opacity: 0;
        }
      }

      /* Match Quality Indicators */
      .match-quality-excellent {
        border-left-color: #10b981 !important;
        background: linear-gradient(
          90deg,
          rgba(16, 185, 129, 0.1) 0%,
          rgba(16, 185, 129, 0.02) 100%
        );
      }

      .match-quality-excellent .line {
        box-shadow: inset 0 0 0 1px rgba(16, 185, 129, 0.2);
      }

      .match-quality-good {
        border-left-color: #3b82f6 !important;
        background: linear-gradient(
          90deg,
          rgba(59, 130, 246, 0.1) 0%,
          rgba(59, 130, 246, 0.02) 100%
        );
      }

      .match-quality-good .line {
        box-shadow: inset 0 0 0 1px rgba(59, 130, 246, 0.2);
      }

      .match-quality-fair {
        border-left-color: #f59e0b !important;
        background: linear-gradient(
          90deg,
          rgba(245, 158, 11, 0.1) 0%,
          rgba(245, 158, 11, 0.02) 100%
        );
      }

      .match-quality-fair .line {
        box-shadow: inset 0 0 0 1px rgba(245, 158, 11, 0.2);
      }

      .match-quality-poor {
        border-left-color: #ef4444 !important;
        background: linear-gradient(
          90deg,
          rgba(239, 68, 68, 0.1) 0%,
          rgba(239, 68, 68, 0.02) 100%
        );
      }

      .match-quality-poor .line {
        box-shadow: inset 0 0 0 1px rgba(239, 68, 68, 0.2);
      }

      /* Enhanced correspondence highlighting */
      .line-container[data-has-correspondence="true"] {
        position: relative;
      }

      .line-container[data-has-correspondence="true"]::after {
        content: "";
        position: absolute;
        right: -1px;
        top: 0;
        bottom: 0;
        width: 3px;
        background: linear-gradient(
          to bottom,
          rgba(59, 130, 246, 0.8) 0%,
          rgba(59, 130, 246, 0.4) 50%,
          rgba(59, 130, 246, 0.8) 100%
        );
        border-radius: 0 2px 2px 0;
      }

      /* Similarity-based visual feedback */
      .line-container[data-similarity] {
        position: relative;
      }

      .line-container[data-similarity]::before {
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: calc(var(--similarity) * 4px);
        background: linear-gradient(
          to right,
          rgba(16, 185, 129, 0.6),
          rgba(59, 130, 246, 0.6)
        );
        transition: all 0.3s ease;
      }

      /* Hover effects for correspondence lines */
      .line-container[data-has-correspondence="true"]:hover {
        background: linear-gradient(
          90deg,
          rgba(59, 130, 246, 0.12) 0%,
          rgba(59, 130, 246, 0.04) 100%
        ) !important;
        transform: translateX(2px);
      }

      /* Enhanced empty line styling */
      .line.empty {
        background: linear-gradient(
          90deg,
          rgba(156, 163, 175, 0.08) 0%,
          rgba(156, 163, 175, 0.02) 100%
        );
        border-left: 4px solid #e5e7eb;
        min-height: 24px;
        position: relative;
        border-radius: 0 4px 4px 0;
      }

      .line.empty::after {
        content: "⌀";
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        color: #9ca3af;
        font-size: 12px;
        opacity: 0.5;
        font-weight: 300;
        transition: all 0.3s ease;
        font-weight: 600;
      }

      /* ===== FAST SCROLLING ENHANCEMENTS ===== */

      /* Global fast scrolling behavior */
      html {
        scroll-behavior: auto;
      }

      /* Enhanced scrollbar styling for webkit browsers */
      .file-content-view::-webkit-scrollbar {
        width: 12px;
        height: 12px;
      }

      .file-content-view::-webkit-scrollbar-track {
        background: linear-gradient(to bottom, #f8fafc, #f1f5f9);
        border-radius: 10px;
        border: 1px solid #e2e8f0;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
      }

      .file-content-view::-webkit-scrollbar-thumb {
        background: linear-gradient(to bottom, #cbd5e1, #94a3b8);
        border-radius: 10px;
        border: 2px solid #f8fafc;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .file-content-view::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(to bottom, #94a3b8, #64748b);
        border-color: #e2e8f0;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        transform: scale(1.05);
      }

      .file-content-view::-webkit-scrollbar-thumb:active {
        background: linear-gradient(to bottom, #64748b, #475569);
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .file-content-view::-webkit-scrollbar-corner {
        background: #f8fafc;
        border-radius: 10px;
      }

      /* Enhanced fast scrolling for content areas */
      .file-content-view {
        scroll-behavior: auto;
        scroll-padding-top: 20px;
        scroll-padding-bottom: 20px;

        /* Additional GPU optimizations for scrolling */
        transform: translate3d(0, 0, 0); /* Force hardware acceleration */
        -webkit-transform: translate3d(0, 0, 0);
        -moz-transform: translate3d(0, 0, 0);
        -ms-transform: translate3d(0, 0, 0);

        /* Optimize scroll performance */
        -webkit-backface-visibility: hidden;
        -moz-backface-visibility: hidden;
        -ms-backface-visibility: hidden;
        backface-visibility: hidden;
        overflow-x: hidden;
        overflow-y: auto;
        /* Enable momentum scrolling on iOS */
        -webkit-overflow-scrolling: touch;
        /* Improve scrolling performance */
        will-change: scroll-position;
      }

      /* Smooth scroll synchronization between panels */
      .diff-side {
        position: relative;
      }

      .diff-side .file-content-view {
        /* Enhanced scroll performance */
        contain: layout style paint;
        /* Smooth momentum scrolling */
        overscroll-behavior: contain;
        /* Better scroll snapping */
        scroll-snap-type: y proximity;
      }

      /* Smooth line transitions during scroll */
      .line-container {
        scroll-snap-align: start;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      }

      /* Enhanced scroll indicators */
      .file-content-view::before {
        content: "";
        position: sticky;
        top: 0;
        left: 0;
        right: 0;
        height: 2px;
        background: linear-gradient(
          90deg,
          transparent 0%,
          rgba(59, 130, 246, 0.3) 20%,
          rgba(59, 130, 246, 0.6) 50%,
          rgba(59, 130, 246, 0.3) 80%,
          transparent 100%
        );
        z-index: 10;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .file-content-view.scrolling::before {
        opacity: 1;
      }

      /* Smooth fade-in animation for content during scroll */
      .line-container {
        opacity: 1;
        transform: translateY(0);
        transition: opacity 0.3s ease, transform 0.3s ease;
      }

      /* Enhanced scroll performance optimizations */
      .file-content-view * {
        /* Optimize rendering during scroll */
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
      }

      /* Custom scrollbar for Firefox */
      .file-content-view {
        scrollbar-width: thin;
        scrollbar-color: #cbd5e1 #f8fafc;
      }

      /* Smooth scroll button styling (if needed) */
      .scroll-to-top {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 50px;
        height: 50px;
        background: linear-gradient(135deg, #3b82f6, #1d4ed8);
        border: none;
        border-radius: 50%;
        color: white;
        font-size: 20px;
        cursor: pointer;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
        z-index: 1000;
      }

      .scroll-to-top.visible {
        opacity: 1;
        visibility: visible;
        transform: translateY(0);
      }

      .scroll-to-top:hover {
        background: linear-gradient(135deg, #1d4ed8, #1e40af);
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4);
      }

      .scroll-to-top:active {
        transform: translateY(0);
        box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
      }

      /* Enhanced scroll synchronization visual feedback */
      .diff-side.syncing {
        position: relative;
      }

      .diff-side.syncing::after {
        content: "";
        position: absolute;
        top: 0;
        right: 0;
        width: 3px;
        height: 100%;
        background: linear-gradient(
          to bottom,
          rgba(59, 130, 246, 0.8),
          rgba(59, 130, 246, 0.4),
          rgba(59, 130, 246, 0.8)
        );
        animation: syncPulse 1s ease-in-out infinite;
        z-index: 5;
      }

      @keyframes syncPulse {
        0%,
        100% {
          opacity: 0.3;
          transform: scaleY(1);
        }
        50% {
          opacity: 1;
          transform: scaleY(1.02);
        }
      }

      /* Smooth transitions for line highlighting during scroll */
      .line-container.scroll-highlight {
        background: linear-gradient(
          90deg,
          rgba(59, 130, 246, 0.1) 0%,
          rgba(59, 130, 246, 0.05) 100%
        );
        border-left-color: #3b82f6;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        transform: translateX(2px);
      }

      /* Enhanced momentum scrolling for better mobile experience */
      @media (max-width: 768px) {
        .file-content-view {
          -webkit-overflow-scrolling: touch;
          scroll-behavior: smooth;
          overscroll-behavior-y: contain;
        }

        .file-content-view::-webkit-scrollbar {
          width: 8px;
        }

        .file-content-view::-webkit-scrollbar-thumb {
          border-radius: 6px;
          border: 1px solid #f8fafc;
        }
      }

      /* Smooth scroll performance optimizations */
      .file-content-view {
        /* Enable hardware acceleration */
        transform: translateZ(0);
        /* Optimize compositing */
        will-change: scroll-position;
        /* Improve scroll performance */
        contain: layout style paint;
      }

      .inline-modified:hover {
        background-color: #fdcb6e;
        box-shadow: 0 4px 8px rgba(255, 193, 7, 0.3);
        transform: translateY(-1px);
      }

      /* Border highlighting for differences */
      .inline-deleted.needs-border {
        border: 3px solid #dc2626;
        box-shadow: 0 0 0 3px rgba(220, 38, 38, 0.3);
      }

      .inline-added.needs-border {
        border: 3px solid #16a34a;
        box-shadow: 0 0 0 3px rgba(22, 163, 74, 0.3);
      }

      /* Enhanced animations for newly highlighted differences */
      @keyframes highlightPulse {
        0% {
          box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7);
          transform: scale(1);
        }
        50% {
          box-shadow: 0 0 0 8px rgba(255, 193, 7, 0.3);
          transform: scale(1.05);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(255, 193, 7, 0);
          transform: scale(1);
        }
      }

      @keyframes slideInFromLeft {
        0% {
          opacity: 0;
          transform: translateX(-20px);
        }
        100% {
          opacity: 1;
          transform: translateX(0);
        }
      }

      @keyframes slideInFromRight {
        0% {
          opacity: 0;
          transform: translateX(20px);
        }
        100% {
          opacity: 1;
          transform: translateX(0);
        }
      }

      .inline-added.new-highlight {
        animation: highlightPulse 1s ease-out, slideInFromRight 0.5s ease-out;
      }

      .inline-deleted.new-highlight {
        animation: highlightPulse 1s ease-out, slideInFromLeft 0.5s ease-out;
      }

      .inline-modified.new-highlight {
        animation: highlightPulse 1s ease-out;
      }

      /* Smooth fade-in for results */
      .results-container {
        animation: fadeIn 0.6s ease-out;
      }

      @keyframes fadeIn {
        0% {
          opacity: 0;
          transform: translateY(20px);
        }
        100% {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .footer {
        padding: 20px 30px;
        border-top: 1px solid var(--border-color);
        display: flex;
        justify-content: flex-end;
        flex-shrink: 0;
        background-color: var(--surface-color);
        position: sticky;
        bottom: 0;
        z-index: 10;
      }
      .btn {
        border: none;
        padding: 10px 20px;
        border-radius: 8px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .btn-primary {
        background-color: var(--color-blue);
        color: white;
      }
      .btn-primary:disabled {
        background-color: #9ca3af;
        cursor: not-allowed;
      }
      .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(4px);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 10;
        animation: fadeIn 0.3s ease-out;
      }
      .spinner {
        width: 50px;
        height: 50px;
        border: 4px solid #e5e7eb;
        border-top: 4px solid var(--color-blue);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 16px;
      }
      .loading-text {
        color: var(--text-primary);
        font-size: 14px;
        font-weight: 500;
        margin-bottom: 8px;
        text-align: center;
      }
      .loading-progress {
        width: 200px;
        height: 4px;
        background-color: #e5e7eb;
        border-radius: 2px;
        overflow: hidden;
        margin-bottom: 8px;
      }
      .loading-progress-bar {
        height: 100%;
        background: linear-gradient(90deg, var(--color-blue), #4f46e5);
        border-radius: 2px;
        animation: progressPulse 2s ease-in-out infinite;
        width: 0%;
        transition: width 0.3s ease;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      @keyframes progressPulse {
        0%,
        100% {
          opacity: 0.8;
        }
        50% {
          opacity: 1;
        }
      }

      /* Enhanced scrollbar styling */
      .file-content-view::-webkit-scrollbar {
        width: 8px;
      }
      .file-content-view::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 4px;
      }
      .file-content-view::-webkit-scrollbar-thumb {
        background: #c1c1c1;
        border-radius: 4px;
      }
      .file-content-view::-webkit-scrollbar-thumb:hover {
        background: #a8a8a8;
      }

      /* Responsive adjustments */
      @media (max-height: 600px) {
        .main-container {
          height: 90vh;
          max-height: none;
        }
      }

      @media (max-width: 768px) {
        body {
          padding: 20px;
        }
        .main-container {
          height: 85vh;
          border-radius: 12px;
        }
        .content-area {
          flex-direction: column;
        }
        .diff-side {
          border-right: none;
          border-bottom: 1px solid var(--border-color);
          min-height: 200px;
        }
        .diff-side:last-child {
          border-bottom: none;
        }
        .header h1 {
          font-size: 1.25rem;
        }
        .header-content {
          flex-direction: column;
          align-items: flex-start;
          gap: 12px;
        }
        .btn-reset {
          align-self: flex-end;
          font-size: 0.8rem;
          padding: 6px 12px;
        }
        .file-content-view {
          font-size: 12px;
        }
        .line-number {
          width: 30px;
          font-size: 10px;
        }
      }

      @media (max-width: 480px) {
        body {
          padding: 10px;
        }
        .main-container {
          height: 90vh;
          border-radius: 8px;
        }
        .header,
        .footer {
          padding: 15px 20px;
        }
        .diff-side {
          padding: 15px;
        }
        .file-content-view {
          font-size: 11px;
          padding: 10px;
        }
        .btn {
          padding: 8px 16px;
          font-size: 0.9rem;
        }
      }

      /* File name display */
      .file-name-display {
        font-size: 12px;
        color: var(--text-secondary);
        padding: 8px 15px;
        background-color: #f8f9fa;
        border-bottom: 1px solid var(--border-color);
        font-weight: 500;
        border-radius: 8px 8px 0 0;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      /* Content loading state */
      .content-loading {
        display: flex;
        justify-content: center;
        align-items: center;
        flex: 1;
        color: var(--text-secondary);
        font-style: italic;
      }

      /* Improved button hover effects */
      .btn:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      /* File content stats */
      .file-stats {
        font-size: 11px;
        color: var(--text-secondary);
        margin-left: auto;
      }

      /* Error message styling */
      .error-message {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        padding: 40px 20px;
        color: var(--text-primary);
      }

      .error-icon {
        font-size: 48px;
        margin-bottom: 16px;
      }

      .error-title {
        font-size: 18px;
        font-weight: 600;
        color: #dc2626;
        margin-bottom: 8px;
      }

      .error-description {
        font-size: 14px;
        color: var(--text-secondary);
        margin-bottom: 16px;
        line-height: 1.5;
      }

      .error-suggestion {
        font-size: 12px;
        color: var(--color-blue);
        background-color: #f0f2ff;
        padding: 8px 12px;
        border-radius: 6px;
        border-left: 3px solid var(--color-blue);
      }

      .comparison-error {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 200px;
        background-color: #fef2f2;
        border: 1px solid #fecaca;
        border-radius: 8px;
        margin: 20px;
      }
    </style>
  </head>
  <body>
    <!-- Ultra-Fast Reading Controls -->
    <div class="reading-progress-bar" id="reading-progress-bar">
      <div
        class="reading-progress-fill"
        id="reading-progress-fill"
        data-progress="0%"
      ></div>
    </div>

    <div class="main-container" id="main-container">
      <div class="header">
        <div class="header-content">
          <h1>DiffChecker Pro 1.1 - Advanced Document Comparison</h1>
          <button
            class="btn btn-reset"
            id="reset-btn"
            title="Start New Comparison"
          >
            <svg
              width="16"
              height="16"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <polyline points="23 4 23 10 17 10"></polyline>
              <polyline points="1 20 1 14 7 14"></polyline>
              <path
                d="m3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"
              ></path>
            </svg>
            Reset
          </button>
        </div>
      </div>
      <div class="content-area">
        <div class="diff-side" id="side1">
          <div class="upload-zone" id="upload-zone-1">
            <p>
              Drag and drop first document or
              <strong>click to browse files</strong>
            </p>
            <p
              style="
                font-size: 0.9rem;
                color: var(--text-secondary);
                margin-top: 8px;
              "
            >
              Supported formats: PDF, DOCX, TXT
            </p>
            <input
              type="file"
              id="file-input-1"
              accept=".pdf,.docx,.txt"
              hidden
            />
          </div>
        </div>
        <div class="diff-side" id="side2">
          <div class="upload-zone" id="upload-zone-2">
            <p>
              Drag and drop second document or
              <strong>click to browse files</strong>
            </p>
            <p
              style="
                font-size: 0.9rem;
                color: var(--text-secondary);
                margin-top: 8px;
              "
            >
              Supported formats: PDF, DOCX, TXT
            </p>
            <input
              type="file"
              id="file-input-2"
              accept=".pdf,.docx,.txt"
              hidden
            />
          </div>
        </div>
      </div>
      <div class="footer">
        <button class="btn btn-primary" id="run-task-btn" disabled>
          Compare Documents
        </button>
      </div>
    </div>

    <script>
      const N8N_WEBHOOK_URL = "https://qtn1910.app.n8n.cloud/webhook/file-diff";

      const fileInput1 = document.getElementById("file-input-1");
      const fileInput2 = document.getElementById("file-input-2");
      const uploadZone1 = document.getElementById("upload-zone-1");
      const uploadZone2 = document.getElementById("upload-zone-2");
      const side1 = document.getElementById("side1");
      const side2 = document.getElementById("side2");
      const runTaskBtn = document.getElementById("run-task-btn");
      const mainContainer = document.getElementById("main-container");

      let file1 = null;
      let file2 = null;

      // --- EVENT LISTENERS ---
      [uploadZone1, fileInput1].forEach((el) => {
        el.addEventListener("click", () => fileInput1.click());
        el.addEventListener("dragover", (e) => {
          e.preventDefault();
          el.classList.add("drag-over");
        });
        el.addEventListener("dragleave", (e) =>
          el.classList.remove("drag-over")
        );
        el.addEventListener("drop", (e) => handleFileDrop(e, 1));
        fileInput1.onchange = (e) => handleFileSelect(e, 1);
      });

      [uploadZone2, fileInput2].forEach((el) => {
        el.addEventListener("click", () => fileInput2.click());
        el.addEventListener("dragover", (e) => {
          e.preventDefault();
          el.classList.add("drag-over");
        });
        el.addEventListener("dragleave", (e) =>
          el.classList.remove("drag-over")
        );
        el.addEventListener("drop", (e) => handleFileDrop(e, 2));
        fileInput2.onchange = (e) => handleFileSelect(e, 2);
      });

      runTaskBtn.addEventListener("click", runComparison);

      // Reset button functionality
      const resetBtn = document.getElementById("reset-btn");
      resetBtn.addEventListener("click", resetComparison);

      // --- FUNCTIONS ---

      function resetComparison() {
        // Clear file variables
        file1 = null;
        file2 = null;

        // Clear file inputs
        fileInput1.value = "";
        fileInput2.value = "";

        // Reset upload zones
        side1.innerHTML = `
                <div class="upload-zone" id="upload-zone-1">
                    <p>Drag and drop first document or <strong>click to browse files</strong></p>
                    <p style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 8px;">Supported formats: PDF, DOCX, TXT</p>
                    <input type="file" id="file-input-1" accept=".pdf,.docx,.txt" hidden>
                </div>
            `;

        side2.innerHTML = `
                <div class="upload-zone" id="upload-zone-2">
                    <p>Drag and drop second document or <strong>click to browse files</strong></p>
                    <p style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 8px;">Supported formats: PDF, DOCX, TXT</p>
                    <input type="file" id="file-input-2" accept=".pdf,.docx,.txt" hidden>
                </div>
            `;

        // Re-assign elements and event listeners
        const newFileInput1 = document.getElementById("file-input-1");
        const newFileInput2 = document.getElementById("file-input-2");
        const newUploadZone1 = document.getElementById("upload-zone-1");
        const newUploadZone2 = document.getElementById("upload-zone-2");

        // Re-attach event listeners for side 1
        [newUploadZone1, newFileInput1].forEach((el) => {
          el.addEventListener("click", () => newFileInput1.click());
          el.addEventListener("dragover", (e) => {
            e.preventDefault();
            el.classList.add("drag-over");
          });
          el.addEventListener("dragleave", (e) =>
            el.classList.remove("drag-over")
          );
          el.addEventListener("drop", (e) => handleFileDrop(e, 1));
          newFileInput1.onchange = (e) => handleFileSelect(e, 1);
        });

        // Re-attach event listeners for side 2
        [newUploadZone2, newFileInput2].forEach((el) => {
          el.addEventListener("click", () => newFileInput2.click());
          el.addEventListener("dragover", (e) => {
            e.preventDefault();
            el.classList.add("drag-over");
          });
          el.addEventListener("dragleave", (e) =>
            el.classList.remove("drag-over")
          );
          el.addEventListener("drop", (e) => handleFileDrop(e, 2));
          newFileInput2.onchange = (e) => handleFileSelect(e, 2);
        });

        // Disable compare button
        runTaskBtn.disabled = true;

        // Show success feedback
        const resetBtn = document.getElementById("reset-btn");
        const originalText = resetBtn.innerHTML;
        resetBtn.innerHTML = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
                Reset Complete
            `;
        resetBtn.style.background =
          "linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%)";
        resetBtn.style.color = "#065f46";
        resetBtn.style.borderColor = "#10b981";

        setTimeout(() => {
          resetBtn.innerHTML = originalText;
          resetBtn.style.background = "";
          resetBtn.style.color = "";
          resetBtn.style.borderColor = "";
        }, 1500);
      }
      function validateFileType(file) {
        const allowedTypes = [".pdf", ".docx", ".txt"];
        const fileName = file.name.toLowerCase();
        const fileExtension = fileName.substring(fileName.lastIndexOf("."));
        return allowedTypes.includes(fileExtension);
      }

      function handleFileDrop(event, side) {
        event.preventDefault();
        event.currentTarget.classList.remove("drag-over");
        const files = event.dataTransfer.files;
        if (files.length > 0) {
          const file = files[0];
          if (!validateFileType(file)) {
            alert(
              "Only PDF, DOCX and TXT files are supported. Please select a different file."
            );
            return;
          }
          if (side === 1) file1 = file;
          else file2 = file;
          renderFileContent(file, side);
        }
      }

      function handleFileSelect(event, side) {
        const files = event.target.files;
        if (files.length > 0) {
          const file = files[0];
          if (!validateFileType(file)) {
            alert(
              "Only PDF, DOCX and TXT files are supported. Please select a different file."
            );
            event.target.value = ""; // Clear the input
            return;
          }
          if (side === 1) file1 = file;
          else file2 = file;
          renderFileContent(file, side);
        }
      }

      async function renderFileContent(file, side) {
        const targetSide = side === 1 ? side1 : side2;
        const fileName = file.name.toLowerCase();
        const fileExtension = fileName.substring(fileName.lastIndexOf("."));

        // Show loading state with better visual feedback
        targetSide.innerHTML = `
                <div class="file-name-display">⏳ ${file.name}</div>
                <div class="content-loading">
                    <div class="spinner" style="width: 24px; height: 24px; margin-bottom: 12px;"></div>
                    <div style="font-weight: 500; margin-bottom: 4px;">Reading file...</div>
                    <div style="font-size: 12px; color: var(--text-secondary);">
                        ${
                          fileExtension === ".pdf"
                            ? "Extracting text from PDF document..."
                            : fileExtension === ".docx"
                            ? "Processing Word document..."
                            : "Reading text file..."
                        }
                    </div>
                </div>
            `;

        try {
          let textContent = "";

          if (fileExtension === ".txt") {
            // Handle TXT files
            textContent = await readTextFile(file);
          } else if (fileExtension === ".docx") {
            // Handle DOCX files
            textContent = await readDocxFile(file);
          } else if (fileExtension === ".pdf") {
            // Handle PDF files
            textContent = await readPdfFile(file);
          }

          // Store converted text for sending to N8N
          if (side === 1) {
            file1.convertedText = textContent;
          } else {
            file2.convertedText = textContent;
          }

          // Calculate file statistics
          const lines = textContent.split("\n").length;
          const chars = textContent.length;
          const sizeKB = (file.size / 1024).toFixed(1);

          targetSide.innerHTML = `
                    <div class="file-name-display">
                        📄 ${file.name}
                        <div class="file-stats">${lines} lines • ${chars} characters • ${sizeKB} KB</div>
                    </div>
                    <div class="file-content-view">${escapeHtml(
                      textContent
                    )}</div>
                `;
          checkRunButtonState();
        } catch (error) {
          console.error("Error reading file:", error);
          const errorMessage = getFileErrorMessage(error, fileExtension);
          targetSide.innerHTML = `
                    <div class="file-name-display">❌ ${file.name}</div>
                    <div class="file-content-view error-message">
                        <div class="error-icon">⚠️</div>
                        <div class="error-title">Unable to read file</div>
                        <div class="error-description">${errorMessage}</div>
                        <div class="error-suggestion">
                            💡 Suggestion: Try selecting a different file or check the file format
                        </div>
                    </div>
                `;
        }
      }

      async function readTextFile(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => resolve(e.target.result);
          reader.onerror = (e) => reject(new Error("Unable to read TXT file"));
          reader.readAsText(file);
        });
      }

      async function readDocxFile(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const arrayBuffer = e.target.result;
              const result = await mammoth.extractRawText({
                arrayBuffer: arrayBuffer,
              });
              resolve(result.value);
            } catch (error) {
              reject(new Error("Unable to read DOCX file"));
            }
          };
          reader.onerror = (e) => reject(new Error("Unable to read DOCX file"));
          reader.readAsArrayBuffer(file);
        });
      }

      async function readPdfFile(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const arrayBuffer = e.target.result;
              const pdf = await pdfjsLib.getDocument({ data: arrayBuffer })
                .promise;
              let textContent = "";

              for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const content = await page.getTextContent();

                // Improved text extraction with better spacing
                let pageText = "";
                let lastY = null;

                for (let j = 0; j < content.items.length; j++) {
                  const item = content.items[j];
                  const currentY = item.transform[5];

                  // Add line break only when Y position changes significantly (new line)
                  if (lastY !== null && Math.abs(currentY - lastY) > 5) {
                    pageText += "\n";
                  } else if (
                    pageText &&
                    !pageText.endsWith(" ") &&
                    !item.str.startsWith(" ")
                  ) {
                    // Add space between words if needed
                    pageText += " ";
                  }

                  pageText += item.str;
                  lastY = currentY;
                }

                // Add page separator only if there's more content
                if (i < pdf.numPages && pageText.trim()) {
                  textContent += pageText + "\n";
                } else {
                  textContent += pageText;
                }
              }

              resolve(textContent.trim());
            } catch (error) {
              reject(new Error("Unable to read PDF file"));
            }
          };
          reader.onerror = (e) => reject(new Error("Unable to read PDF file"));
          reader.readAsArrayBuffer(file);
        });
      }

      function checkRunButtonState() {
        runTaskBtn.disabled = !(file1 && file2);
      }

      async function runComparison() {
        if (!file1 || !file2) return;

        try {
          // Step 1: Preparing files
          showLoading(true, "Preparing files for comparison...", 20);

          const formData = new FormData();

          // Always send converted text as TXT files
          const txtFile1 = new File(
            [file1.convertedText || ""],
            file1.name.replace(/\.(pdf|docx)$/i, ".txt"),
            { type: "text/plain" }
          );
          const txtFile2 = new File(
            [file2.convertedText || ""],
            file2.name.replace(/\.(pdf|docx)$/i, ".txt"),
            { type: "text/plain" }
          );

          formData.append("file1", txtFile1);
          formData.append("file2", txtFile2);

          // Step 2: Uploading to server
          showLoading(true, "Uploading files to server...", 40);

          const response = await fetch(N8N_WEBHOOK_URL, {
            method: "POST",
            body: formData,
          });

          if (!response.ok) {
            throw new Error(`Server error: ${response.statusText}`);
          }

          // Step 3: Processing response
          showLoading(true, "Processing comparison results...", 70);

          const result = await response.json();

          if (result.error) {
            throw new Error(result.message);
          }

          // Step 4: Rendering results
          showLoading(true, "Displaying comparison results...", 90);

          // Apply advanced line matching algorithm
          const enhancedResult = applyAdvancedLineMatching(result);

          // Small delay to show final progress
          await new Promise((resolve) => setTimeout(resolve, 500));

          displayDiffResults(enhancedResult);
        } catch (error) {
          console.error("Comparison error:", error);
          showLoading(false);

          // Show user-friendly error message
          const errorContainer = document.createElement("div");
          errorContainer.className = "comparison-error";
          errorContainer.innerHTML = `
                    <div class="error-message">
                        <div class="error-icon">❌</div>
                        <div class="error-title">Comparison error</div>
                        <div class="error-description">${getComparisonErrorMessage(
                          error
                        )}</div>
                        <div class="error-suggestion">
                            💡 Suggestion: Check file content and try again
                        </div>
                    </div>
                `;

          side1.innerHTML = "";
          side2.innerHTML = "";
          side1.appendChild(errorContainer.cloneNode(true));
        } finally {
          showLoading(false);
        }
      }

      function applyAdvancedLineMatching(result) {
        if (!result.diff_result || !Array.isArray(result.diff_result)) {
          return result;
        }

        const diffResult = result.diff_result;
        const enhancedDiff = [];

        // Advanced line matching algorithm
        for (let i = 0; i < diffResult.length; i++) {
          const currentDiff = diffResult[i];

          // For modified lines, try to find better matches using similarity scoring
          if (currentDiff.type === "modified") {
            const similarity = calculateLineSimilarity(
              currentDiff.content1 || "",
              currentDiff.content2 || ""
            );

            // If similarity is very low, consider splitting into separate add/delete operations
            if (similarity < 0.3) {
              // Look ahead to see if there are better matches
              const betterMatch = findBetterLineMatch(
                currentDiff,
                diffResult,
                i
              );

              if (betterMatch) {
                enhancedDiff.push(...betterMatch);
                continue;
              }
            }

            // Enhance the modified line with better inline diff
            currentDiff.similarity = similarity;
            currentDiff.matchQuality = getMatchQuality(similarity);
          }

          // For added/deleted lines, try to find corresponding pairs
          if (currentDiff.type === "added" || currentDiff.type === "deleted") {
            const pairedLine = findCorrespondingLine(
              currentDiff,
              diffResult,
              i
            );
            if (pairedLine) {
              currentDiff.correspondingLine = pairedLine;
              currentDiff.hasCorrespondence = true;
            }
          }

          enhancedDiff.push(currentDiff);
        }

        // Apply line grouping for better visual organization
        const groupedDiff = groupRelatedLines(enhancedDiff);

        return {
          ...result,
          diff_result: groupedDiff,
        };
      }

      function calculateLineSimilarity(line1, line2) {
        if (!line1 && !line2) return 1.0;
        if (!line1 || !line2) return 0.0;

        // Normalize lines for comparison
        const normalized1 = line1.toLowerCase().trim().replace(/\s+/g, " ");
        const normalized2 = line2.toLowerCase().trim().replace(/\s+/g, " ");

        // Use Levenshtein distance for similarity calculation
        const distance = levenshteinDistance(normalized1, normalized2);
        const maxLength = Math.max(normalized1.length, normalized2.length);

        if (maxLength === 0) return 1.0;

        return 1 - distance / maxLength;
      }

      function levenshteinDistance(str1, str2) {
        const matrix = [];

        for (let i = 0; i <= str2.length; i++) {
          matrix[i] = [i];
        }

        for (let j = 0; j <= str1.length; j++) {
          matrix[0][j] = j;
        }

        for (let i = 1; i <= str2.length; i++) {
          for (let j = 1; j <= str1.length; j++) {
            if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
              matrix[i][j] = matrix[i - 1][j - 1];
            } else {
              matrix[i][j] = Math.min(
                matrix[i - 1][j - 1] + 1,
                matrix[i][j - 1] + 1,
                matrix[i - 1][j] + 1
              );
            }
          }
        }

        return matrix[str2.length][str1.length];
      }

      function findBetterLineMatch(currentDiff, diffResult, currentIndex) {
        const content1 = currentDiff.content1 || "";
        const content2 = currentDiff.content2 || "";

        // Look for better matches in nearby lines
        const searchRange = Math.min(5, diffResult.length - currentIndex - 1);
        let bestMatch = null;
        let bestSimilarity = 0;

        for (let i = 1; i <= searchRange; i++) {
          const nextIndex = currentIndex + i;
          if (nextIndex < diffResult.length) {
            const nextDiff = diffResult[nextIndex];

            if (nextDiff.type === "modified") {
              const similarity1 = calculateLineSimilarity(
                content1,
                nextDiff.content1 || ""
              );
              const similarity2 = calculateLineSimilarity(
                content2,
                nextDiff.content2 || ""
              );
              const avgSimilarity = (similarity1 + similarity2) / 2;

              if (avgSimilarity > bestSimilarity && avgSimilarity > 0.7) {
                bestSimilarity = avgSimilarity;
                bestMatch = {
                  index: nextIndex,
                  similarity: avgSimilarity,
                };
              }
            }
          }
        }

        // If no better match found, return null
        return null;
      }

      function findCorrespondingLine(targetDiff, diffResult, currentIndex) {
        const targetContent = targetDiff.content1 || targetDiff.content2 || "";
        const targetType = targetDiff.type;
        const oppositeType = targetType === "added" ? "deleted" : "added";

        // Search in a reasonable range around the current position
        const searchRange = 10;
        const startIndex = Math.max(0, currentIndex - searchRange);
        const endIndex = Math.min(
          diffResult.length,
          currentIndex + searchRange
        );

        let bestMatch = null;
        let bestSimilarity = 0;

        for (let i = startIndex; i < endIndex; i++) {
          if (i === currentIndex) continue;

          const candidateDiff = diffResult[i];
          if (candidateDiff.type === oppositeType) {
            const candidateContent =
              candidateDiff.content1 || candidateDiff.content2 || "";
            const similarity = calculateLineSimilarity(
              targetContent,
              candidateContent
            );

            if (similarity > bestSimilarity && similarity > 0.5) {
              bestSimilarity = similarity;
              bestMatch = {
                index: i,
                similarity: similarity,
                content: candidateContent,
              };
            }
          }
        }

        return bestMatch;
      }

      function getMatchQuality(similarity) {
        if (similarity >= 0.9) return "excellent";
        if (similarity >= 0.7) return "good";
        if (similarity >= 0.5) return "fair";
        return "poor";
      }

      function groupRelatedLines(diffResult) {
        const grouped = [];
        let currentGroup = [];
        let lastType = null;

        for (let i = 0; i < diffResult.length; i++) {
          const diff = diffResult[i];

          // Start a new group if type changes significantly
          if (lastType && lastType !== diff.type && currentGroup.length > 0) {
            // Add group metadata
            if (currentGroup.length > 1) {
              currentGroup[0].groupStart = true;
              currentGroup[currentGroup.length - 1].groupEnd = true;
              currentGroup.forEach((item, index) => {
                item.groupSize = currentGroup.length;
                item.groupIndex = index;
              });
            }

            grouped.push(...currentGroup);
            currentGroup = [];
          }

          currentGroup.push(diff);
          lastType = diff.type;
        }

        // Handle the last group
        if (currentGroup.length > 0) {
          if (currentGroup.length > 1) {
            currentGroup[0].groupStart = true;
            currentGroup[currentGroup.length - 1].groupEnd = true;
            currentGroup.forEach((item, index) => {
              item.groupSize = currentGroup.length;
              item.groupIndex = index;
            });
          }
          grouped.push(...currentGroup);
        }

        return grouped;
      }

      function displayDiffResults(data) {
        const diffResult = data.diff_result || [];
        let html1 = "";
        let html2 = "";

        diffResult.forEach((diff, index) => {
          const escapedContent1 = escapeHtml(diff.content1);
          const escapedContent2 = escapeHtml(diff.content2);
          const lineNum1 = diff.displayLineNumber1
            ? `<span class="line-number">${diff.displayLineNumber1}</span>`
            : '<span class="line-number"></span>';
          const lineNum2 = diff.displayLineNumber2
            ? `<span class="line-number">${diff.displayLineNumber2}</span>`
            : '<span class="line-number"></span>';

          // Generate unique IDs for synchronized highlighting
          const lineId = `line-${index}`;
          const containerClass1 = getContainerClass(diff.type, "left");
          const containerClass2 = getContainerClass(diff.type, "right");

          // Add advanced matching attributes
          let matchingAttributes = "";
          let correspondenceIndicator = "";

          if (diff.similarity !== undefined) {
            matchingAttributes += ` data-similarity="${diff.similarity}" data-match-quality="${diff.matchQuality}"`;
          }

          if (diff.hasCorrespondence) {
            matchingAttributes += ` data-has-correspondence="true" data-correspondence-similarity="${diff.correspondingLine.similarity}"`;
            correspondenceIndicator = `<span class="correspondence-indicator" title="Similarity: ${Math.round(
              diff.correspondingLine.similarity * 100
            )}%"></span>`;
          }

          if (diff.groupStart) {
            matchingAttributes += ` data-group-start="true" data-group-size="${diff.groupSize}"`;
          }

          if (diff.groupEnd) {
            matchingAttributes += ` data-group-end="true"`;
          }

          switch (diff.type) {
            case "unchanged":
              html1 += `<div class="line-container" id="${lineId}-left" data-line-pair="${lineId}"${matchingAttributes}>${lineNum1}<span class="line">${escapedContent1}</span></div>`;
              html2 += `<div class="line-container" id="${lineId}-right" data-line-pair="${lineId}"${matchingAttributes}>${lineNum2}<span class="line">${escapedContent2}</span></div>`;
              break;
            case "deleted":
              html1 += `<div class="line-container ${containerClass1}" id="${lineId}-left" data-line-pair="${lineId}"${matchingAttributes}>${correspondenceIndicator}${lineNum1}<span class="line deleted">${escapedContent1}</span></div>`;
              html2 += `<div class="line-container ${containerClass2}" id="${lineId}-right" data-line-pair="${lineId}"${matchingAttributes}>${lineNum2}<span class="line empty"></span></div>`;
              break;
            case "added":
              html1 += `<div class="line-container ${containerClass1}" id="${lineId}-left" data-line-pair="${lineId}"${matchingAttributes}>${lineNum1}<span class="line empty"></span></div>`;
              html2 += `<div class="line-container ${containerClass2}" id="${lineId}-right" data-line-pair="${lineId}"${matchingAttributes}>${correspondenceIndicator}${lineNum2}<span class="line added">${escapedContent2}</span></div>`;
              break;
            case "modified":
              // Add similarity-based styling
              let qualityClass = "";
              if (diff.matchQuality) {
                qualityClass = ` match-quality-${diff.matchQuality}`;
              }

              // Check if inline diff is available from backend
              if (
                diff.inlineDiff &&
                diff.inlineDiff.segments1 &&
                diff.inlineDiff.segments2
              ) {
                // Render with backend inline highlighting
                const inlineHtml1 = renderInlineSegments(
                  diff.inlineDiff.segments1
                );
                const inlineHtml2 = renderInlineSegments(
                  diff.inlineDiff.segments2
                );
                html1 += `<div class="line-container ${containerClass1}${qualityClass}" id="${lineId}-left" data-line-pair="${lineId}"${matchingAttributes}>${lineNum1}<span class="line modified-old">${inlineHtml1}</span></div>`;
                html2 += `<div class="line-container ${containerClass2}${qualityClass}" id="${lineId}-right" data-line-pair="${lineId}"${matchingAttributes}>${lineNum2}<span class="line modified-new">${inlineHtml2}</span></div>`;
              } else {
                // Use client-side word-level diff for better highlighting
                const wordDiff = performWordLevelDiff(
                  diff.content1 || "",
                  diff.content2 || ""
                );
                const inlineHtml1 = renderInlineSegments(wordDiff.segments1);
                const inlineHtml2 = renderInlineSegments(wordDiff.segments2);
                html1 += `<div class="line-container ${containerClass1}${qualityClass}" id="${lineId}-left" data-line-pair="${lineId}"${matchingAttributes}>${lineNum1}<span class="line modified-old">${inlineHtml1}</span></div>`;
                html2 += `<div class="line-container ${containerClass2}${qualityClass}" id="${lineId}-right" data-line-pair="${lineId}"${matchingAttributes}>${lineNum2}<span class="line modified-new">${inlineHtml2}</span></div>`;
              }
              break;
          }
        });

        side1.innerHTML = `<div class="file-content-view">${html1}</div>`;
        side2.innerHTML = `<div class="file-content-view">${html2}</div>`;

        // Add synchronized hover effects for line pairs
        addSynchronizedHoverEffects();

        // Add smooth scroll synchronization
        addScrollSynchronization();

        // Remove animation classes after animation completes
        setTimeout(() => {
          const animatedElements1 = side1.querySelectorAll(".new-highlight");
          const animatedElements2 = side2.querySelectorAll(".new-highlight");
          animatedElements1.forEach((element) => {
            element.classList.remove("new-highlight");
          });
          animatedElements2.forEach((element) => {
            element.classList.remove("new-highlight");
          });
        }, 1000);
      }

      function getContainerClass(diffType, side) {
        switch (diffType) {
          case "deleted":
            return "has-deletion";
          case "added":
            return "has-addition";
          case "modified":
            return "has-modification";
          default:
            return "";
        }
      }

      function addSynchronizedHoverEffects() {
        const allLineContainers = document.querySelectorAll(
          ".line-container[data-line-pair]"
        );

        allLineContainers.forEach((container) => {
          container.addEventListener("mouseenter", function () {
            const pairId = this.getAttribute("data-line-pair");
            const pairedElements = document.querySelectorAll(
              `[data-line-pair="${pairId}"]`
            );

            pairedElements.forEach((element) => {
              element.style.transform = "scale(1.02)";
              element.style.zIndex = "5";
              element.style.boxShadow = "0 4px 16px rgba(59, 130, 246, 0.2)";
            });
          });

          container.addEventListener("mouseleave", function () {
            const pairId = this.getAttribute("data-line-pair");
            const pairedElements = document.querySelectorAll(
              `[data-line-pair="${pairId}"]`
            );

            pairedElements.forEach((element) => {
              element.style.transform = "";
              element.style.zIndex = "";
              element.style.boxShadow = "";
            });
          });
        });
      }

      function addScrollSynchronization() {
        const contentView1 = side1.querySelector(".file-content-view");
        const contentView2 = side2.querySelector(".file-content-view");

        if (!contentView1 || !contentView2) return;

        let isScrolling1 = false;
        let isScrolling2 = false;

        contentView1.addEventListener("scroll", function () {
          if (!isScrolling2) {
            isScrolling1 = true;
            const scrollPercentage =
              this.scrollTop / (this.scrollHeight - this.clientHeight);
            const targetScrollTop =
              scrollPercentage *
              (contentView2.scrollHeight - contentView2.clientHeight);
            contentView2.scrollTop = targetScrollTop;

            setTimeout(() => {
              isScrolling1 = false;
            }, 100);
          }
        });

        contentView2.addEventListener("scroll", function () {
          if (!isScrolling1) {
            isScrolling2 = true;
            const scrollPercentage =
              this.scrollTop / (this.scrollHeight - this.clientHeight);
            const targetScrollTop =
              scrollPercentage *
              (contentView1.scrollHeight - contentView1.clientHeight);
            contentView1.scrollTop = targetScrollTop;

            setTimeout(() => {
              isScrolling2 = false;
            }, 100);
          }
        });
      }

      function showLoading(isLoading, message = "Processing...", progress = 0) {
        let overlay = document.getElementById("loading-overlay");
        if (isLoading && !overlay) {
          overlay = document.createElement("div");
          overlay.id = "loading-overlay";
          overlay.className = "loading-overlay";
          overlay.innerHTML = `
                    <div class="spinner"></div>
                    <div class="loading-text">${message}</div>
                    <div class="loading-progress">
                        <div class="loading-progress-bar" style="width: ${progress}%"></div>
                    </div>
                    <div style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">
                        Please wait a moment...
                    </div>
                `;
          mainContainer.appendChild(overlay);

          // Animate progress bar
          if (progress > 0) {
            setTimeout(() => {
              const progressBar = overlay.querySelector(
                ".loading-progress-bar"
              );
              if (progressBar) {
                progressBar.style.width = progress + "%";
              }
            }, 100);
          }
        } else if (isLoading && overlay) {
          // Update existing overlay
          const loadingText = overlay.querySelector(".loading-text");
          const progressBar = overlay.querySelector(".loading-progress-bar");
          if (loadingText) loadingText.textContent = message;
          if (progressBar) progressBar.style.width = progress + "%";
        } else if (!isLoading && overlay) {
          overlay.style.opacity = "0";
          setTimeout(() => {
            if (overlay && overlay.parentNode) {
              overlay.remove();
            }
          }, 300);
        }
      }

      // Word-level diff algorithm
      function performWordLevelDiff(text1, text2) {
        if (!text1 && !text2) return { segments1: [], segments2: [] };
        if (!text1)
          return {
            segments1: [],
            segments2: [{ type: "added", text: text2 }],
          };
        if (!text2)
          return {
            segments1: [{ type: "deleted", text: text1 }],
            segments2: [],
          };

        const words1 = text1.split(/(\s+)/);
        const words2 = text2.split(/(\s+)/);

        const diff = diffWords(words1, words2);

        const segments1 = [];
        const segments2 = [];

        diff.forEach((change) => {
          if (change.added) {
            segments2.push({ type: "added", text: change.value });
          } else if (change.removed) {
            segments1.push({ type: "deleted", text: change.value });
          } else {
            segments1.push({ type: "unchanged", text: change.value });
            segments2.push({ type: "unchanged", text: change.value });
          }
        });

        return { segments1, segments2 };
      }

      function diffWords(words1, words2) {
        const m = words1.length;
        const n = words2.length;

        // Create LCS matrix
        const lcs = Array(m + 1)
          .fill()
          .map(() => Array(n + 1).fill(0));

        for (let i = 1; i <= m; i++) {
          for (let j = 1; j <= n; j++) {
            if (words1[i - 1] === words2[j - 1]) {
              lcs[i][j] = lcs[i - 1][j - 1] + 1;
            } else {
              lcs[i][j] = Math.max(lcs[i - 1][j], lcs[i][j - 1]);
            }
          }
        }

        // Backtrack to find differences
        const result = [];
        let i = m,
          j = n;

        while (i > 0 || j > 0) {
          if (i > 0 && j > 0 && words1[i - 1] === words2[j - 1]) {
            result.unshift({ value: words1[i - 1] });
            i--;
            j--;
          } else if (j > 0 && (i === 0 || lcs[i][j - 1] >= lcs[i - 1][j])) {
            result.unshift({ value: words2[j - 1], added: true });
            j--;
          } else if (i > 0) {
            result.unshift({ value: words1[i - 1], removed: true });
            i--;
          }
        }

        return result;
      }

      function renderInlineSegments(segments) {
        if (!segments || !Array.isArray(segments)) return "";

        return segments
          .map((segment) => {
            const escapedText = escapeHtml(segment.text);
            const borderClass = " needs-border new-highlight";
            switch (segment.type) {
              case "unchanged":
                return escapedText;
              case "deleted":
                return `<span class="inline-deleted${borderClass}">${escapedText}</span>`;
              case "added":
                return `<span class="inline-added${borderClass}">${escapedText}</span>`;
              default:
                return escapedText;
            }
          })
          .join("");
      }

      function escapeHtml(text) {
        if (text === null || text === undefined) return "";
        return String(text)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      function getFileErrorMessage(error, fileExtension) {
        const errorMsg = error.message.toLowerCase();

        if (errorMsg.includes("network") || errorMsg.includes("fetch")) {
          return "Network connection error. Please check your internet connection.";
        }

        if (errorMsg.includes("cors") || errorMsg.includes("cross-origin")) {
          return "File cannot be accessed due to security restrictions.";
        }

        if (fileExtension === ".pdf") {
          return "PDF file is corrupted or unreadable. Please try a different PDF file.";
        }

        if (fileExtension === ".docx") {
          return "Word file is corrupted or unreadable. Please try a different Word file.";
        }

        if (errorMsg.includes("size") || errorMsg.includes("large")) {
          return "File is too large. Please select a file smaller than 10MB.";
        }

        if (errorMsg.includes("format") || errorMsg.includes("invalid")) {
          return "File format not supported. Only .txt, .pdf, .docx are supported";
        }

        return `Unknown error: ${error.message}`;
      }

      function getComparisonErrorMessage(error) {
        const errorMsg = error.message.toLowerCase();

        if (
          errorMsg.includes("network") ||
          errorMsg.includes("fetch") ||
          errorMsg.includes("failed to fetch")
        ) {
          return "Unable to connect to server. Please check your network connection.";
        }

        if (errorMsg.includes("cors") || errorMsg.includes("cross-origin")) {
          return "CORS error. Please check N8N webhook configuration.";
        }

        if (errorMsg.includes("timeout")) {
          return "Request timeout. File may be too large or server is busy.";
        }

        if (errorMsg.includes("500") || errorMsg.includes("internal server")) {
          return "Server error. Please check N8N logs and try again.";
        }

        if (errorMsg.includes("404") || errorMsg.includes("not found")) {
          return "N8N endpoint not found. Please check webhook URL.";
        }

        if (errorMsg.includes("400") || errorMsg.includes("bad request")) {
          return "Invalid data sent. Please check file content.";
        }

        return `Unknown error: ${error.message}`;
      }

      // ===== SMOOTH SCROLLING ENHANCEMENTS =====

      class SmoothScrollManager {
        constructor() {
          this.leftPanel = null;
          this.rightPanel = null;
          this.isScrolling = false;
          this.scrollTimeout = null;
          this.syncScrolling = false;
          this.lastScrollTime = 0;
          this.scrollVelocity = 0;
          this.momentumAnimation = null;

          this.init();
        }

        init() {
          // Initialize scroll synchronization when panels are created
          this.setupScrollSynchronization();
          this.createScrollToTopButton();
          this.setupMomentumScrolling();
          this.setupScrollIndicators();
        }

        setupScrollSynchronization() {
          // This will be called when diff panels are created
          document.addEventListener("DOMContentLoaded", () => {
            this.findScrollPanels();
          });
        }

        findScrollPanels() {
          this.leftPanel = document.querySelector("#side1 .file-content-view");
          this.rightPanel = document.querySelector("#side2 .file-content-view");

          if (this.leftPanel && this.rightPanel) {
            this.bindScrollEvents();
          }
        }

        bindScrollEvents() {
          let leftScrolling = false;
          let rightScrolling = false;

          // Enhanced scroll synchronization with smooth transitions
          this.leftPanel.addEventListener("scroll", (e) => {
            if (!rightScrolling) {
              leftScrolling = true;
              this.syncScroll(this.leftPanel, this.rightPanel);
              this.handleScrollStart(this.leftPanel);

              clearTimeout(this.scrollTimeout);
              this.scrollTimeout = setTimeout(() => {
                leftScrolling = false;
                this.handleScrollEnd(this.leftPanel);
              }, 150);
            }
          });

          this.rightPanel.addEventListener("scroll", (e) => {
            if (!leftScrolling) {
              rightScrolling = true;
              this.syncScroll(this.rightPanel, this.leftPanel);
              this.handleScrollStart(this.rightPanel);

              clearTimeout(this.scrollTimeout);
              this.scrollTimeout = setTimeout(() => {
                rightScrolling = false;
                this.handleScrollEnd(this.rightPanel);
              }, 150);
            }
          });

          // Add smooth scroll behavior
          [this.leftPanel, this.rightPanel].forEach((panel) => {
            panel.style.scrollBehavior = "smooth";
            this.setupWheelScrolling(panel);
          });
        }

        syncScroll(sourcePanel, targetPanel) {
          if (!this.syncScrolling) {
            this.syncScrolling = true;

            // Calculate scroll ratio
            const scrollRatio =
              sourcePanel.scrollTop /
              (sourcePanel.scrollHeight - sourcePanel.clientHeight);
            const targetScrollTop =
              scrollRatio *
              (targetPanel.scrollHeight - targetPanel.clientHeight);

            // Smooth scroll to target position
            targetPanel.scrollTo({
              top: targetScrollTop,
              behavior: "smooth",
            });

            // Add visual sync indicator
            this.showSyncIndicator(sourcePanel.closest(".diff-side"));

            setTimeout(() => {
              this.syncScrolling = false;
            }, 100);
          }
        }

        setupWheelScrolling(panel) {
          // Advanced scroll tracking for adaptive acceleration
          let scrollHistory = [];
          let lastScrollTime = 0;
          let momentumTimer = null;

          panel.addEventListener(
            "wheel",
            (e) => {
              e.preventDefault();

              const currentTime = Date.now();
              const delta = e.deltaY;

              // Track scroll velocity for adaptive acceleration
              scrollHistory.push({ time: currentTime, delta: Math.abs(delta) });

              // Keep only recent scroll events (last 200ms)
              scrollHistory = scrollHistory.filter(
                (event) => currentTime - event.time < 200
              );

              // Calculate adaptive multiplier based on scroll frequency and velocity
              let baseMultiplier = 10; // Increased from 2.5 to 10
              let adaptiveMultiplier = baseMultiplier;

              if (scrollHistory.length > 3) {
                // Fast consecutive scrolling - increase multiplier up to 25x
                const avgVelocity =
                  scrollHistory.reduce((sum, event) => sum + event.delta, 0) /
                  scrollHistory.length;
                const scrollFrequency = scrollHistory.length / 0.2; // events per second

                if (avgVelocity > 50 && scrollFrequency > 10) {
                  adaptiveMultiplier = Math.min(25, baseMultiplier * 2.5);
                } else if (avgVelocity > 30 && scrollFrequency > 5) {
                  adaptiveMultiplier = Math.min(20, baseMultiplier * 2);
                } else if (scrollFrequency > 3) {
                  adaptiveMultiplier = Math.min(15, baseMultiplier * 1.5);
                }
              }

              const scrollAmount = delta * adaptiveMultiplier;

              // Calculate new scroll position
              const newScrollTop = panel.scrollTop + scrollAmount;

              // Ultra-fast scroll to new position
              panel.scrollTo({
                top: Math.max(
                  0,
                  Math.min(
                    newScrollTop,
                    panel.scrollHeight - panel.clientHeight
                  )
                ),
                behavior: "auto",
              });

              // Clear momentum timer
              if (momentumTimer) {
                clearTimeout(momentumTimer);
              }

              // Add momentum scrolling effect
              momentumTimer = setTimeout(() => {
                if (scrollHistory.length > 2) {
                  const lastDelta =
                    scrollHistory[scrollHistory.length - 1].delta;
                  const momentum = lastDelta * adaptiveMultiplier * 0.3;

                  if (momentum > 10) {
                    const momentumScrollTop =
                      panel.scrollTop + (delta > 0 ? momentum : -momentum);
                    panel.scrollTo({
                      top: Math.max(
                        0,
                        Math.min(
                          momentumScrollTop,
                          panel.scrollHeight - panel.clientHeight
                        )
                      ),
                      behavior: "auto",
                    });
                  }
                }
                scrollHistory = [];
              }, 100);

              lastScrollTime = currentTime;
            },
            { passive: false }
          );
        }

        handleScrollStart(panel) {
          panel.classList.add("scrolling");
          this.isScrolling = true;

          // Add scroll highlight to visible lines
          this.highlightVisibleLines(panel);
        }

        handleScrollEnd(panel) {
          panel.classList.remove("scrolling");
          this.isScrolling = false;

          // Remove scroll highlights
          this.removeScrollHighlights(panel);
        }

        highlightVisibleLines(panel) {
          const lines = panel.querySelectorAll(".line-container");
          const panelRect = panel.getBoundingClientRect();

          lines.forEach((line) => {
            const lineRect = line.getBoundingClientRect();
            const isVisible =
              lineRect.top >= panelRect.top &&
              lineRect.bottom <= panelRect.bottom;

            if (isVisible) {
              line.classList.add("scroll-highlight");
            } else {
              line.classList.remove("scroll-highlight");
            }
          });
        }

        removeScrollHighlights(panel) {
          const lines = panel.querySelectorAll(
            ".line-container.scroll-highlight"
          );
          lines.forEach((line) => {
            line.classList.remove("scroll-highlight");
          });
        }

        showSyncIndicator(diffSide) {
          diffSide.classList.add("syncing");
          setTimeout(() => {
            diffSide.classList.remove("syncing");
          }, 1000);
        }

        createScrollToTopButton() {
          const scrollButton = document.createElement("button");
          scrollButton.className = "scroll-to-top";
          scrollButton.innerHTML = "↑";
          scrollButton.title = "Scroll to top";

          scrollButton.addEventListener("click", () => {
            if (this.leftPanel && this.rightPanel) {
              this.leftPanel.scrollTo({ top: 0, behavior: "auto" });
              this.rightPanel.scrollTo({ top: 0, behavior: "auto" });
            }
          });

          document.body.appendChild(scrollButton);

          // Show/hide button based on scroll position
          window.addEventListener("scroll", () => {
            if (window.pageYOffset > 300) {
              scrollButton.classList.add("visible");
            } else {
              scrollButton.classList.remove("visible");
            }
          });
        }

        setupMomentumScrolling() {
          // Enhanced momentum scrolling for better mobile experience
          document.addEventListener(
            "touchstart",
            (e) => {
              this.lastScrollTime = Date.now();
              this.scrollVelocity = 0;
            },
            { passive: true }
          );

          document.addEventListener(
            "touchmove",
            (e) => {
              const currentTime = Date.now();
              const timeDelta = currentTime - this.lastScrollTime;

              if (timeDelta > 0) {
                this.scrollVelocity = e.touches[0].clientY / timeDelta;
                this.lastScrollTime = currentTime;
              }
            },
            { passive: true }
          );

          document.addEventListener(
            "touchend",
            (e) => {
              if (Math.abs(this.scrollVelocity) > 0.5) {
                this.startMomentumScroll();
              }
            },
            { passive: true }
          );
        }

        startMomentumScroll() {
          if (this.momentumAnimation) {
            cancelAnimationFrame(this.momentumAnimation);
          }

          const animate = () => {
            if (Math.abs(this.scrollVelocity) > 0.1) {
              if (this.leftPanel && this.rightPanel) {
                const scrollAmount = this.scrollVelocity * 10;

                this.leftPanel.scrollBy({
                  top: scrollAmount,
                  behavior: "smooth",
                });

                this.rightPanel.scrollBy({
                  top: scrollAmount,
                  behavior: "smooth",
                });
              }

              this.scrollVelocity *= 0.95; // Friction
              this.momentumAnimation = requestAnimationFrame(animate);
            }
          };

          this.momentumAnimation = requestAnimationFrame(animate);
        }

        setupScrollIndicators() {
          // Add scroll progress indicators
          const createProgressIndicator = (panel, side) => {
            const indicator = document.createElement("div");
            indicator.className = `scroll-progress scroll-progress-${side}`;
            indicator.style.cssText = `
                        position: absolute;
                        top: 0;
                        right: 0;
                        width: 4px;
                        height: 0%;
                        background: linear-gradient(to bottom, #3b82f6, #1d4ed8);
                        transition: height 0.2s ease;
                        z-index: 10;
                        border-radius: 0 0 2px 2px;
                    `;

            panel.parentElement.style.position = "relative";
            panel.parentElement.appendChild(indicator);

            panel.addEventListener("scroll", () => {
              const scrollPercent =
                (panel.scrollTop / (panel.scrollHeight - panel.clientHeight)) *
                100;
              indicator.style.height = `${Math.min(
                100,
                Math.max(0, scrollPercent)
              )}%`;
            });
          };

          // This will be called when panels are available
          const checkPanels = () => {
            if (this.leftPanel && this.rightPanel) {
              createProgressIndicator(this.leftPanel, "left");
              createProgressIndicator(this.rightPanel, "right");
            } else {
              setTimeout(checkPanels, 100);
            }
          };

          checkPanels();
        }

        // Method to reinitialize when new content is loaded
        reinitialize() {
          this.findScrollPanels();
        }
      }

      // Initialize smooth scroll manager
      const smoothScrollManager = new SmoothScrollManager();

      // Reinitialize scroll manager when comparison is complete
      // Listen for when diff content is loaded
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === "childList" && mutation.addedNodes.length > 0) {
            // Check if diff content was added
            const hasFileContent = Array.from(mutation.addedNodes).some(
              (node) =>
                node.nodeType === Node.ELEMENT_NODE &&
                (node.classList?.contains("file-content-view") ||
                  node.querySelector?.(".file-content-view"))
            );

            if (hasFileContent) {
              setTimeout(() => {
                smoothScrollManager.reinitialize();
              }, 100);
            }
          }
        });
      });

      // Start observing the document for changes
      observer.observe(document.body, {
        childList: true,
        subtree: true,
      });

      // Advanced keyboard navigation for ultra-fast reading
      document.addEventListener("keydown", (e) => {
        if (smoothScrollManager.leftPanel && smoothScrollManager.rightPanel) {
          // Don't interfere with input fields
          if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") {
            return;
          }

          const lineHeight = 20; // Approximate line height
          const viewportHeight = smoothScrollManager.leftPanel.clientHeight;
          const pageScrollAmount = viewportHeight * 0.9; // 90% of viewport for page scroll
          const lineScrollAmount = lineHeight * 3; // 3 lines at a time
          const fastScrollAmount = lineHeight * 10; // 10 lines for fast navigation

          switch (e.key) {
            // Space/Shift+Space for page navigation (like PDF readers)
            case " ":
              e.preventDefault();
              const pageAmount = e.shiftKey
                ? -pageScrollAmount
                : pageScrollAmount;
              smoothScrollManager.leftPanel.scrollBy({
                top: pageAmount,
                behavior: "auto",
              });
              smoothScrollManager.rightPanel.scrollBy({
                top: pageAmount,
                behavior: "auto",
              });
              break;

            // J/K for line-by-line navigation (Vim-style)
            case "j":
            case "J":
              e.preventDefault();
              smoothScrollManager.leftPanel.scrollBy({
                top: lineScrollAmount,
                behavior: "auto",
              });
              smoothScrollManager.rightPanel.scrollBy({
                top: lineScrollAmount,
                behavior: "auto",
              });
              break;

            case "k":
            case "K":
              e.preventDefault();
              smoothScrollManager.leftPanel.scrollBy({
                top: -lineScrollAmount,
                behavior: "auto",
              });
              smoothScrollManager.rightPanel.scrollBy({
                top: -lineScrollAmount,
                behavior: "auto",
              });
              break;

            // Page Up/Page Down for fast page navigation
            case "PageUp":
              e.preventDefault();
              smoothScrollManager.leftPanel.scrollBy({
                top: -pageScrollAmount,
                behavior: "auto",
              });
              smoothScrollManager.rightPanel.scrollBy({
                top: -pageScrollAmount,
                behavior: "auto",
              });
              break;

            case "PageDown":
              e.preventDefault();
              smoothScrollManager.leftPanel.scrollBy({
                top: pageScrollAmount,
                behavior: "auto",
              });
              smoothScrollManager.rightPanel.scrollBy({
                top: pageScrollAmount,
                behavior: "auto",
              });
              break;

            // Arrow keys for precise control
            case "ArrowUp":
              if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                smoothScrollManager.leftPanel.scrollBy({
                  top: -fastScrollAmount,
                  behavior: "auto",
                });
                smoothScrollManager.rightPanel.scrollBy({
                  top: -fastScrollAmount,
                  behavior: "auto",
                });
              }
              break;

            case "ArrowDown":
              if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                smoothScrollManager.leftPanel.scrollBy({
                  top: fastScrollAmount,
                  behavior: "auto",
                });
                smoothScrollManager.rightPanel.scrollBy({
                  top: fastScrollAmount,
                  behavior: "auto",
                });
              }
              break;

            // Home/End for document navigation
            case "Home":
              if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                smoothScrollManager.leftPanel.scrollTo({
                  top: 0,
                  behavior: "auto",
                });
                smoothScrollManager.rightPanel.scrollTo({
                  top: 0,
                  behavior: "auto",
                });
              }
              break;

            case "End":
              if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                smoothScrollManager.leftPanel.scrollTo({
                  top: smoothScrollManager.leftPanel.scrollHeight,
                  behavior: "auto",
                });
                smoothScrollManager.rightPanel.scrollTo({
                  top: smoothScrollManager.rightPanel.scrollHeight,
                  behavior: "auto",
                });
              }
              break;

            // G for "Go to" navigation (Vim-style)
            case "g":
            case "G":
              if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                if (e.shiftKey || e.key === "G") {
                  // Go to end
                  smoothScrollManager.leftPanel.scrollTo({
                    top: smoothScrollManager.leftPanel.scrollHeight,
                    behavior: "auto",
                  });
                  smoothScrollManager.rightPanel.scrollTo({
                    top: smoothScrollManager.rightPanel.scrollHeight,
                    behavior: "auto",
                  });
                } else {
                  // Go to beginning
                  smoothScrollManager.leftPanel.scrollTo({
                    top: 0,
                    behavior: "auto",
                  });
                  smoothScrollManager.rightPanel.scrollTo({
                    top: 0,
                    behavior: "auto",
                  });
                }
              }
              break;
          }
        }
      });
    </script>
  </body>
</html>
